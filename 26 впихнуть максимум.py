'''
ТИП - впихнуть максимум.

https://education.yandex.ru/ege/task/ba452f56-bd43-4a4f-80dd-e326e1bf9edb
Системный администратор раз в неделю создаёт архив пользовательских файлов.
Однако объём диска, куда он помещает архив, может быть меньше, чем суммарный объём архивируемых файлов.
Известно, какой объем занимает файл каждого пользователя. По заданной информации об объёме файлов пользователей и
свободном объеме на архивном диске определите максимальное число пользователей, чьи файлы можно сохранить в архиве.
Также укажите максимальный размер имеющегося файла, который может быть сохранён в архиве при условии, что сохранены
файлы максимально возможного числа пользователей.

В первой строке входного файла находятся два числа:
S — размер свободного места на диске (натуральное число, не превышающее 10 000) и
N — количество пользователей (натуральное число, не превышающее 1000).
В следующих N строках находятся значения объёмов файлов каждого пользователя
(все числа натуральные, не превышающие 100), каждое в отдельной строке.

Так как нужно впихнуть максимально много, то надо брать самые минимальные.
Так как нам нужно ещё и максимально возможный при максимальном количестве, то надо отдельно проверить,
какой максимальный элемент можно впихнуть вместо последнего минимального.
'''
f = open('task26files/26_1.txt', 'r')  # Открыть

s, n = map(int, f.readline().split())  # Первая строка содержит вместимость диска и количество фалов
ls = sorted([int(x) for x in f])  # Считываем размер всех файлов и сразу сортируем

count = 0  # Для количества
last = 0  # Для последнего элемента
m = 0  # Для максимально возможного последнего
for i in ls:  # По каждому элементу
    if s >= i:  # Если мы можем впихнуть целый элемент
        s -= i  # То мы его впихиваем (остаток места уменьшится)
        count += 1  # Количество впихнутых +1
        last = i  # Сохраняем последний впихнутый
    else:  # Если целый впихнуть уже нельзя
        if s >= (i-last):  # То проверяем, может его можно впихнуть вместо него элемент пом
            m = i  # Сохраняем максимально впихнутый
        else:  # А если и вместо последнего уже не влазит
            break  # То дальше смотреть не надо
print(count, m)  # Вот и ответ
'''
Это задание можно делать в exсel
Для этого мы копируем всё, кроме первой строчки, сортируем, а дальше вычитаем пока можем. 
Когда уже не можем, ручками смотрим остаток и ищем максимальное подходящее.
Подробнее расписывать не буду, извинись
'''
