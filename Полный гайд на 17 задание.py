'''
Это полный гайд по 17 заданию.
Здесь я постараюсь учесть все вариации задания, все условия и ими можно пользоваться как конструктором.
Но я настоятельно рекомендую попытаться понять принципы работы.
Два файла для программ:
15333 https://kompege.ru/files/RhwTQ79ZJ.txt
13858 https://kompege.ru/files/mIB1b6roP.txt

_________________________________________________________________________________________________________
Открытие файла и запись в список
'''
f = open('17.txt', 'r')  #
ls = [int(x) for x in f]  #

'''
_________________________________________________________________________________________________________
Часто одно из условий обращается к максимальному элементу из файла с каким-то свойством
'''
max_krat_19 = max([x for x in ls if abs(x) % 19 == 0])  # Ищет все, кратное 19 и берет максимальное
max_end_19 = max([x for x in ls if str(abs(x))[-2:] == '19'])  # Ищет все, оканчивающееся на 19 и берет максимальное
max_3_znach = max([x for x in ls if len(str(abs(x))) == 3])  # Ищет все трехзначные и берет максимальное
'''
Раз гайд полный, то надо бы все расписать
1) a = [ x for x in ls if ....] это тоже самое, что:
a = []
for x in ls:
    if x ...:
        a.append(x)
2) тепреь про все условия:
-Если в файле есть отрицательные числа, то всегда надежнее взять модуль числа, а именно abs(x).
Добавляем все равно просто x
-Для кратных мы берем число, и проверяем остаток от деления на число и если он 0, то все ок.
-Для оканчивающихся переводим число в строку, берем последние n символов str(x)[:-n],
и если они равны нужному окончанию, то все ок. N - длинна нужного конца.
Не забудьте кавычки  if str(x)[:-n] = 'число'
-Для n-значного числа abs(x) в случае отрицательных обязателен. Здесь преобразуем в строку и смотрим
на ее длину, она должны быть n. if len(str(abs(x)) == n
'''


'''
_________________________________________________________________________________________________________
Дальше надо пройтись по всем двойкам/тройкам/четверкам, это в сущности ничего не меняет.
'''
for i in range(1, len(ls)):  # двойка
    pair = [ls[i-1], ls[i]]
    pass

for i in range(2, len(ls)):  # тройка
    troika = [ls[i-2], ls[i-1], ls[i]]
    pass

for i in range(3, len(ls)):  # четверка (думаю суть вы уловили)
    cheverka = [ls[i-3], ls[i-2], ls[i-1], ls[i]]
    pass


'''
_________________________________________________________________________________________________________
Дальше есть несколько условий, которые можно почти всегда написать очень просто,
если использовать генератор(это тот самый [x for x in cheverka if x ...])
Я попытаюсь собрать побольше вариантов условий
'''
pair = []
troika = []
cheverka = []

# Два числа четырехзначные
chtz = [x for x in cheverka if len(str(abs(x))) == 4]
if len(chtz) == 2:
    pass

# Только одно число четное (=делится на 2 без остатка)
chetnoe = [x for x in troika if x % 2 == 0]
if len(chetnoe) == 1:
    pass

# Является квадратом натурального числа
is_sqr = [x for x in cheverka if x**0.5 == int(x**0.5)]
is_sqr_with_negative = [x for x in cheverka if x > 0 and x**0.5 == int(x**0.5)]  # Добавьте если есть отрицательные
'''
Проверяет что корень числа - целое число. (я проверил, работает)
А как работает if, я думаю, вы поняли, так что обойдемся без него
'''

# В конце будут ещё более сложные приколы, а именно кол-во делителей, простые и что-нибудь ещё


# Иногда важно что число сразу какое-то и какое-то, тогда просто and в условии генератора
# Например четырехзначное и делится на 7
chtz_and_delitsa_na_7 = [x for x in cheverka if (len(str(abs(x))) == 4) and (x % 7 == 0)]


'''
Так же иногда условие требует работать с суммой.
При этом иногда не просто суммой, а, например, сумму квадратов.
'''
s = sum(cheverka)  # Просто сумма
s_sqr = sum([x**2 for x in cheverka])  # Сумма квадратов. Сумма чего-то ещё по аналогии
s_positive = sum([x for x in cheverka if x > 0])  # Сумма только каких-то чисел.


'''
_________________________________________________________________________________________________________
Соответственно если наша пара/тройка/четверка удовлетворяет всему, то надо её учесть.
Обычно нужно количество и максимальная сумма
Заодно напишем полную программу для номера 15333  на КЕГЭ:
Определите количество пар последовательности, в которых хотя бы одно число больше максимального элемента 
последовательности, кратного 19. В ответе запишите количество найденных пар, 
затем максимальную из сумм элементов таких пар.
'''
f = open('17_15333.txt', 'r')
ls = [int(x) for x in f]
count = 0
max_sum = 0
m_k_19 = max([x for x in ls if x % 19 == 0])
for i in range(1, len(ls)):
    pair = [ls[i-1], ls[i]]
    more_than_max = [x for x in pair if x > m_k_19]
    if len(more_than_max) >= 1:
        s = sum(pair)
        max_sum = max(s, max_sum)
        count += 1
print('Это ответ к номеру 15333: ', count, max_sum)


'''
Используя как конструктор блоки, данные выше, можно решить ~90% семнадцатых.
Дальше я поясню некоторые механики работы(когда понимаешь как что то работает, всегда лучше задания получаются)
и разберу приколы посложнее.
'''


'''
_________________________________________________________________________________________________________
Начну про оканчивается на xxx. Тут мы используем такую прекрасную вещь как слайсинг:
СПИСОК[С элемента: ДО элемента(не включительно, как в for): Шаг]
А строка в питоне, это по сути список символов.
Можно оставить значение пустым, тогда оно будет по умолчанию [Начало: конец: шаг 1]
Примеры:
Естественно счет с 0, это же списки)
[n:] С n-ного элемента до конца
[5:] Все элементы, начиная с пятого ( 5 6 7...)

[:n] До n-ного элемента не включительно
[:5] элементы 0 1 2 3 4

[x:y] С x до y(у не включительно)
[5:8] Элементы 5 6 7

[:-1] 1 2 3 4 ... предпоследний 
[-3:] -3 -2 -1 элементы, те три последних
[::2] элементы 0 2 4 6 8
[1::2] элементы 1 3 5 7 9
'''


'''
_________________________________________________________________________________________________________
Теперь посложнее условия
'''
'''
ВСЕ ДОЛЖНЫ ЗАПОМНИТЬ ФУНКЦИЮ ПОИСКА ДЕЛИТЕЛЕЙ
пишем ее до цикла. Иногда говорят не учитывать как делитель единицу или само число
'''
def deliteli(ch):
    del_set = set()  # Сюда будем закидывать найденные
    s.add(1)  # Если нужно учитывать 1, то закидываем
    s.add(ch)  # Если нужно учитывать ch, то закидываем
    for x in range(2, int(ch**0.5)+1):  # Проходим по всем целым от 2, до корня числа
        if ch % x == 0:  # Если число делитель, то
            s.add(x)  # Добавляем число
            s.add(ch//x)  # Добавляем результат деления на это число
    return list(s)  # Возвращаем все делители числа
for i in range(1, len(ls)):
    pass
'''
Соответсвенно с помощью этой функции мы можем находить список делителей, а значит и понять, простое ли число
'''
# У одного числа ровно 3 различных делителя(включая 1 и само число)
dif_del_3 = [x for x in cheverka if len(deliteli(x)) == 3]

# Простое число. (А значит делители 1 и само число
simples = [x for x in cheverka if len(deliteli(x)) == 2]

# Все числа оканчиваются на одну и ту же цифру
'''
Такую жесть я что-то не помню.
Предлагаю так: создаем set() с последними цифрами, и если его длинна 1, то все ок.
'''
s = {str(x)[-1] for x in cheverka}
'''
Сам придуммал усложнение: в четверке две на одну и две на другую
'''
end = [str(x)[-1] for x in cheverka]  # для каждого элемента сохраняем его последнюю цифру
mask = [end.count(y) for y in end]  # Смотрим сколько элементов закончилось на такую же
if mask.count('2') == 4:  # Любой подходящий вариант будет выглядеть как 2 2 2 2:
    # (12 11 11 12)>('2' '1' '1' '2')>(2 2 2 2) или (11 11 12 12)>('1' '1' '2' '2')>(2 2 2 2)
    # В общем как в 9-ом в питоне
    pass


'''
_________________________________________________________________________________________________________
Вот номер 13858  на КЕГЭ:
хотя бы два из трёх элементов являются четырёхзначными числами,
а произведение элементов тройки не больше квадрата минимального элемента последовательности, оканчивающегося на 25.
В ответе запишите количество найденных троек чисел, затем максимальное из произведений элементов таких троек.
'''
f = open('17_13858.txt', 'r')
ls = [int(x) for x in f]
min_end_25 = min([x for x in ls if str(x)[-2:] == '25'])  # Не перепутайте, именно [-2:] вернет 2 последних
# (а то я думаю, сука, фигли ты не работаешь)

count = 0  # Создаем перед циклом
max_proisv = (-100_000)*3  # Создаем перед циклом, на всякий стоит ставить минимально возможным
for i in range(2, len(ls)):  # для троек
    troika = [ls[i-2], ls[i-1], ls[i]]
    chtz = [x for x in troika if len(str(abs(x))) == 4]
    if len(chtz) >= 2:
        proisv = 1
        for x in troika:
            proisv = proisv * x
        if proisv <= (min_end_25**2):
            count += 1
            max_proisv = max(max_proisv, proisv)
print('Это ответ к номеру 13858: ', count, max_proisv)





