'''
2 Префиксные суммы это когда нам нужна непрерывная подпоследовательность с каким-то свойством.
Преребирать все варианты сумм это для файла Б вообще нереально.
Мы будем проходить по файлу 1 раз, смотреть  на получающуюся сумму, а так же сохранять её
что бы потом можно было вычесть из другой.
Например:
s(10 превых) == 11
s(12 первых) == 21
Нам надо что бы сумма делилась на 10
Мы можем вычесть из s(12) s(10) и получить 10.
Суммы мы будем сохранять как раз по признаку делимости на 10, а точнее остатка от деления на 10.
А теперь на конкретном примере
Кстати пример этот сложнее базовой версии, где мы просто собираем суммы по остатку от деления и ищем максимальную

№ 12257 ЕГКР 16.12.23 (Уровень: Базовый)
Компания, ведущая мониторинг линии электропередач, получила N числовых значений измерений высоты растений (в мм)
вдоль этой линии, которые выполнялись последовательно друг за другом. Высоту растений с точки зрения безопасности линии
электропередач оценивают на основе анализа сумм всех возможных непрерывных подпоследовательностей полученных
числовых значений, среди которых требуется выбрать подпоследовательность с максимальной суммой, кратной К = 113.
Среди таких непрерывных подпоследовательностей необходимо выбрать подпоследовательность с наибольшим количеством
элементов, то есть ту, в которой суммируются числовые значения высот наибольшего количества растений,
в ответе укажите её длину.

Входные данные
Дано два входных файла (файл А и файл В), каждый из которых в первой строке содержит число N (1 < N< 10 000 000) — количество
измерений высоты растений (в мм). Каждая из следующих N строк содержит одно натуральное число, не превышающее 10000 —
числовое значение одного результата измерения.

Выходные данные
В ответе укажите два числа: сначала значение искомой величины для файла А, затем — для файла В.


Тут нас интересует именно длинна, при чем она должна быть максимальной.
Будем сохранять минимальные суммы минимальной длинны по остатку от деления на 113


'''

f = open('27-A_12257.txt', 'r')  # Открываем
n = int(f.readline())  # Первая строка это n - количество чисел

ls = [int(x) for x in f]  # Распаковал файл, я привык так делать, но можно и в цикле уже читать
print(ls[:10])  # Ну и проверить правильность считывания файла
s = 0  # Для общей суммы
s_ost = [[10000000, 0] for _ in range(113)]
'''
Создает массив [100000, 0] 113 раз, для каждого остатка от деления на 113
Первое число у нас будет суммой, а второе длинной, при которой мы получили эту сумму
'''

ms = 0  # Для максимальной суммы
ml = 0  # Для её длины


for i in range(len(ls)):  # Идем по жадому числу
    s += ls[i]  # Прибавляем в общую сумму само число
    if s % 113 == 0:  # Если общая сумма кратна 113
        if s >= ms:  # То можно проверить, не получилась ли она больше предыдущей максимальной
            ms = s  # Если да то сохраняем сумму
            ml = i + 1  # И длину. +1 потому что индексы с 0.
    '''
    А теперь главный фокус. Как получить сумму кратную 113? 
    Из суммы А вычесть сумму Б с таким же остатком от деления на 113.
    Соответственно мы будем сохранять суммы по определенному остатку от деления.
    '''
    s1 = s - s_ost[s % 113][0]  # Сумма равна общей сумме - сумме с таким же остатком от деления.
    # [0] берет именно первое число, отвечающее у нас за сумму
    s1_l = i+1 - s_ost[s % 113][1]  # Длина равна длине общей суммы - длина вычитаемой суммы.
    # [1] берет именно второе число, отвечающее у нас за длину
    if s1 > ms:  # Если новая сумма получилась больше старой максимальной
        ms = s1  # То сохраяем сумму
        ml = s1_l  # И длину
    elif s1 == ms:  # Так же стоит проверить, может сумма такая же
        if s1_l > ml:  # Но длина больше (по условию нужна максимальная с максимальной длиной)
            ml = s1_l  # Тогда надо длину обновить
    '''
    А теперь сохраним общую сумму. 
    Так как по условию сумма должны быть максимальной и длиннейшей, то вычитаемая сумма должна быть меньше и короче.
    Условие меньше мы проверяем
    А вот короче каждая следующая точно не может получиться, это же сумма всех
    '''
    if s < s_ost[s%113][0]:  # Если меньше сохраненной ([0] потому что нужна сумма)
        s_ost[s%113] = [s, i+1]  # То сохраняем сумму и длину
print(f"Сумма: {ms}, длина: {ml}")  # Ответ, нужно второе число - длина

'''
Так же файл А стоит проверить переборной программой 
'''
f = open('27-A_12257.txt', 'r')  # Открыть
n = f.readline()  # первая строка n
ls = [int(x) for x in f]  # Считать все
ms = 0  # для суммы
ml = 0  # для длины
for x in range(len(ls)):  # Будем перебирать все. Х это начало
    for y in range(x, len(ls)):  # У это конец
        s = sum(ls[x:y+1])  # Считаем сумму (от x до y включительно)
        if s % 113 == 0:  # Если кратно 113
            if ms < s:  # Если сумма больше
                ms = s  # Обновляем сумму
                ml = (y-x+1)  # Обновляем длину
            elif ms == s:  # Если сумма равна
                if ml < (y-x):  # То проверяем, может длина меньше
                    ml = (y-x+1)  # обновим её
print(f"Сумма: {ms}, длина: {ml}")  # Ответ, нужно второе число - длина
