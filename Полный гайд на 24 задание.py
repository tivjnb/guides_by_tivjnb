'''
Это полный гайд по 24 заданию.
Я попробую объяснить как можно больше заданий. Тут надо уловить основные принципы.
Перед каждым решением переменная и условие, замените False на True у той задачи, которую хотите запустить.
Иначе все запускалось бы всегда, а это долго и бессмысленно

Файлы:
Для номера 15339: https://kompege.ru/files/Ph7cB8EWL.txt
Для номера 14645: https://kompege.ru/files/XQ1oKTnkz.txt
Для номера 14646: https://kompege.ru/files/oF6qYP-xT.txt
Для номера 14643: https://kompege.ru/files/H-cv2_5hW.txt
Для номера 12931: https://kompege.ru/files/qkR7RjeWn.txt
Для номера 13715: https://kompege.ru/files/BPn7T1BoJ.txt
Для номера 13085: https://kompege.ru/files/qJ8bde_Gx.txt
Для номера 14704: https://kompege.ru/files/_Ix8d_teN.txt
Для СтатГрада: https://online.olimpiada.ru/smt-portal/files/a38f709939c18a513add2a11fa69c8594c765ff6.txt
Блин, оказывается ссылка просто в браузере открывает, так что лучше просто номер задания на КЕГЭ вводите,
статградовская работает



Осталось поискать задачу с полиндромом, но пока что все
'''


'''
________________________________________________________________________________________________________________________
№15339 КЕГЭ. Досрок. Уровень средний.
Текстовый файл состоит из символов латинского алфавита A, B, C, и цифр 6, 7, 8, 9.
Определите в прилагаемом файле максимальное количество идущих подряд символов, 
среди которых никакая буква не стоит рядом с буквой, а цифра – с цифрой.
'''
n15339 = False  # Это чтобы при каждом запуске не выполнялось, замените на True если нужен этот номер
if n15339:
    f = open('task24files/24_15339.txt', 'r').read()  # Здесь нам нужна сразу вся последовательность
    # У нас не должно быть ситуации цифра-цифра или буква-буква.
    # Предлагаю все цифры заменить на один символ, а буквы на другой, так будет гораздо удобнее с ними работать
    f = f.replace('7', '6').replace('8', '6').replace('9', '6')
    f = f.replace('B', 'A').replace('C', 'A')
    '''
    Теперь весь файл это 6 и А. 
    Дальше можно пройтись по каждому символу и динамически обнулять последовательность.
    '''
    ln = 0  # Актуальная длина
    m = 0  # Максимальная длина
    pre = ''  # Предыдущий символ
    for i in f:  # Проходимся по каждому
        if pre == i:  # Если предыдущий символ такой же как и тот, который сейчас,
            # то начинаем считать сначала(но этот символ надо учесть, так что 1, а не 0)
            ln = 1
        else:  # Если предыдущий символ другой
            ln += 1  # то длина += 1
            m = max(m, ln)  # Ну и проверяем, не вышла ли наша длина больше максимальной
        pre = i  # Обновляем предыдущий
    print("Задание №15339: ", m)  # УРА, ответ


'''
________________________________________________________________________________________________________________________
№14645  КЕГЭ. Уровень средний.
Во входном файле в строчку записаны заглавные буквы английского алфавита.
Требуется найти самую длинную последовательность, в которой гласные и согласные буквы чередуются.
В ответ запишите длину найденной последовательности.
Примечание: Y – гласная буква.
В общем она как предыдущая, но посложнее
'''
n14645 = False
if n14645:
    f = open('task24files/24.4_14645.txt', 'r').read()
    #  Здесь можно как и в предыдущей заменить все символы, но я предлагаю автоматизировать замену
    gl = 'EYUIOA'  # Список гласных
    sogl = 'QWRTPSDFGHJKLZXCVBNM'  # Список согласных
    print(len(gl+sogl))  # Проверка, что взяли все буквы. Проверка это хорошо. (Английский алфавит это 26 букв)
    for i in sogl:  # Меняем каждую согласную на 1
        f = f.replace(i, '1')
    for i in gl:  # А каждую гласную на 2
        f = f.replace(i, '2')
    # Теперь все гласные - 1, а согласные - 2. Можно было взять и другие символы, главное, что бы их не было в файле
    # ну или были, но нам не мешали, например согласную на другую согласную, а гласные на другую гласную

    # Дальше как в предыдущей задаче
    ln = 0  # Актуальная длина
    m = 0  # Максимальная длина
    pre = ''  # Предыдущий символ
    for i in f:  # Проходимся по каждому
        if pre == i:  # Если предыдущий символ такой же как и тот, который сейчас,
            # то начинаем считать сначала(но этот символ надо учесть, так что 1, а не 0)
            ln = 1
        else:  # Если предыдущий символ другой
            ln += 1  # то длина += 1
            m = max(m, ln)  # Ну и проверяем, не вышла ли наша длина больше максимальной
        pre = i  # Обновляем предыдущий
    print("Задание №14645: ", m)


'''_____________________________________________________________________________________________________________________
№14646  КЕГЭ уровень средний
В файле в одну строку записаны заглавные английские буквы.
Задача – определить наиболее часто встречающийся символ после комбинации из трех одинаковых символов.
В случае, если наиболее встречающихся символов несколько,
в ответ нужно записать последний по алфавиту символ и число его повторений без пробела.
Так, например, для строки QQQPGGGGHHHG можно выделить комбинации GGGG, QQQP, HHHG. Ответ к примеру – G2.
'''
n14646 = False
if n14646:
    f = open('task24files/24.3_14646.txt', 'r').read()
    # Предлагаю пройтись во всем четверкам, и если первые три элемента одинаковые, то добавить в словарь по букве
    after_3 = dict()  # Собственно сам словарь
    for i in range(3, len(f)):  # Проходимся по всем четверкам
        if f[i-3] == f[i-2] and f[i-3] == f[i-1]:  # Если первые три элемента одинаковые
            last = f[i]  # запишем в переменную, нам его еще несколько раз использовать
            if last in after_3.keys():  # Если в словаре уже есть такая буква (dict.keys() Это все ключи)
                after_3[last] += 1  # то можно прибавить
            else:  # А вот если буквы в словаре нет, то
                after_3[last] = 1  # надо создать
    max_repeat = max(after_3.values())  # Максимальный из значений (dict.values() возвращает все значения ключей)
    for k, v in after_3.items():  # Теперь пройдемся по всем парам (ключ, значение)
        if v == max_repeat:  # Если кол-во повторений равно максимальному
            print(k, v)  # то печатаем
    # В ответ может вывести несколько букв, в соответствии с заданием выбираем последнюю по алфавиту


'''_____________________________________________________________________________________________________________________
№14643 КЕГЭ уровень базовый
Текстовый файл состоит не более чем из 106 символов M, A, X.
Определите максимальное количество идущих подряд символов, среди которых нет подстроки AXMM
'''
n14643 = False
if n14643:
    f = open('task24files/24.13_14643.txt', 'r').read()
    # Раз нам нужны последовательности без AXMM, то можно все "AXMM" превратить в "AXM XMM",
    # разделить по пробелам и посчитать все длины
    f = f.replace('AXMM', 'AXM XMM')  # Превращаем "AXMM" в "AXM XMM"
    f = f.split()  # Делим по пробелам (теперь f это список строк)
    max_len = 0  # Ищем самую длинную
    for x in f:  # берем каждую строку
        max_len = max(max_len, len(x))  # Смотрим на её длину
    max_len_2 = max([len(x) for x in f])  # То же самое в одну строку
    print("Ответ на 14543: ", max_len, "И показываю что в одну строчку такой же", max_len_2)


'''_____________________________________________________________________________________________________________________
№12931  КЕГЭ уровень базовый
Текстовый файл состоит из символов T, U, V, W, X, Y и Z. 
В прилагаемом файле определите максимальное количество символов в непрерывной подпоследовательности, 
состоящей из идущих подряд групп символов VWXYZ в указанном порядке. 
При этом в начале и в конце искомой последовательности группа символов VWXYZ может быть неполной.
Искомая подпоследовательность должна содержать не менее одной полной группы символов VWXYZ.
Например, условию задачи удовлетворяют: XYZVWXYZVWXYZV; VWXYZ и т.п.
'''
n12931 = False
if n12931:
    f = open('task24files/24_12931.txt', 'r').read()
    '''
    В таких заданиях просто заменяем последовательность на длину, 
    а потом постепенно сокращая неполные заменяем, но с пробелом с той стороны, 
    где обрывается(это позволит просто считать цифры).
    Потом проходимся по списку и считаем
    '''
    f = f.replace('VWXYZ', '5')  # Сначала полную на её длину
    f = f.replace('WXYZ', ' 4')  # Потом постепенно укорачивающиеся обрубки на длину и пробел с той стороны,
    f = f.replace('VWXY', '4 ')  # где последовательность оборвется
    f = f.replace('XYZ', ' 3')
    f = f.replace('VWX', '3 ')
    f = f.replace('YZ', ' 2')
    f = f.replace('VW', '2 ')
    f = f.replace('Z', ' 1')
    f = f.replace('V', '1 ')
    m = 0  # Для максимального
    ln = 0  # Для длины
    for i in f:  # По каждому символу
        if i in '12345':  # Если это цифра, то
            ln += int(i)  # мы точно прибавляем
            m = max(m, ln)  # и сравниваем
        else:  # А если это не часть последовательности, то обнуляем
            # Пробел гарантирует нам, что лишний обрубок не попадет, он просто обнулится на конце
            ln = 0
    print("12931: ", m)  # Ура, ответ


'''_____________________________________________________________________________________________________________________
№13715 КЕГЭ уровень средний
Текстовый файл состоит из символов A, B, C, D и E.
Определите в прилагаемом файле максимальное количество идущих подряд символов,
среди которых комбинация символов AB встречается ровно 50 раз.
'''
n13715 = False
if n13715:
    f = open('task24files/24_13715.txt', 'r').read()
    '''
    В задачах, когда у нас подпоследовательность встречается n раз 
    мы просто разделяем все по подпоследовательностям и берем по n кусков
    Чуть поясню за split:
    Если строку "AB....AB...ABAB..." засплитить по AB, то не выходе у нас получится
    ['','....','...','','...'] Тут важно, что если AB стоят на концах, или их несколько рядом, 
    то мы получим элемент - '', и это прекрасно, оно помогает нам считать
    '''
    f = f.replace('AB', 'A B')
    '''
    Зачем реплейсить? А потому, что если у нас в некоторой подпоследовательность 50 AB, 
    нам никто не мешает взять в начале только B и в конце только A.
    А просто прибавить 2 нельзя. Так что эта задача хитрожопее, она скамит на двойку
    (скорее всего сработает, но раз в 100 задач искомая подпоследовательность будет самой первой, или последней,
    а тогда надо прибавить лишь 1, в общем так надежнее)
    Если нам нужно не более скольки-то символов, то реплейсить естественно не нужно
    '''
    f = f.split(' ')  # Сплит
    lens = [len(x) for x in f]  # Длины всех элементов
    m = 0  # Для максимального
    for i in range(50, len(lens)):  # Все по 51 подряд
        # 51 кусок потому, что 1 кусок до AB,
        # 49 кусков между первым и последним AB,
        # 1 кусок после последнего AB
        m = max(sum(lens[i-50: i+1]), m)  # Сравниваем с максимальным. До i+1 тк не включительно
    print("13715 :", m)  # Результат


'''_____________________________________________________________________________________________________________________
№13085 КЕГЭ уровень средний(нифига это не средний, это вообще со СтатГрада)
Текстовый файл содержит только заглавные буквы латинского алфавита (ABC…Z).
Определите максимальное количество идущих подряд символов,
среди которых ровно по одному разу встречаются буквы X и Y.

С первого взгляда может показаться, что она похожа на предыдущую, но не тут то было.
Я напишу сюда два решения, сначала кабанова, а затем свое. Кабанова попроще будет, ео точно посмотрите
'''
n13085_kabanov = False
n13085_tivjnb = False
if n13085_kabanov:
    '''
    В чем суть решения:
    1)"X">"X " и "Y">"Y "
    2)Сплитим по пробелам. Теперь у нас комбинации вида "....(X или Y)" + на конце возможно без него
    3)Берем по три. Теперь у нас комбинации вида "....(X или Y)....(X или Y)....(X или Y)".
    Убираем последний символ, и если у нас 1 X и 1 Y, то смотрим на длину.
    Но если у нас последняя комбинация, то там в конце не всегда X или Y, её проверим отдельно.
    Даже если забыть про эту особенность, ответ скорее всего выйдет правильный.
    '''
    f = open('task24files/24_13085.txt', 'r').read()
    f = f.replace('X', 'X ')
    f = f.replace('Y', 'Y ')
    f = f.split(' ')
    m = 0
    for i in range(2, len(f)-1):  # До -1 тк последнюю отдельно проверим, она особая
        comb = f[i-2] + f[i-1] + f[i]
        comb = comb[:-1]
        if comb.count('X') == 1 and comb.count('Y') == 1:
            m = max(len(comb), m)

    last_comb = f[-3]+f[-2]+f[-1]
    if last_comb[-1] == "X" or last_comb[-1] == "Y":
        last_comb = last_comb[:-1]
    m = max(len(last_comb), m)
    print("13085_Kabanov: ", m)

if n13085_tivjnb:
    '''
    Мое решение сложнее, соответственно вам скорее всего нет смысла его смотреть, лучше кабанова запомнить.
    Я его оставлю просто по приколу
    Оно скорее методы нужные для 27 использует тут это ни к чему
    Идея:
    Идем по каждому символу
    Есть нулевой индекс, и после него всегда по 0 или 1 X и Y. Если их по 1, то можем сравнивать
    '''
    f = open('task24files/24_13085.txt', 'r').read()
    x_ind = -1  # Индекс последнего Х
    y_ind = -1  # Индекс последнего Y
    zero_ind = 0  # Индекс, от которого считаем (включительно).
    m = 0  # Максимальная длина
    for ind, i in enumerate(f, 0):
        '''
        enumerate([a, b, c, d, e], x)>[(x, a), (x+1, b), (x+2, c), (x+3, d), (x+4, e)]
        Те, каждый элемент с его порядковым номером, начиная с X. 
        В нашем случае то же самое, что:
        for ind in f:
            i = f[ind]
        Но тк это мое решение, использую что хочу)
        '''
        if i == 'X':  # Если элемент - X, то
            if x_ind > zero_ind:  # Если предыдущий наш X был после того элемента, с которого мы считаем, то
                zero_ind = x_ind + 1  # мы начинаем считать со следующего после него
            x_ind = ind  # И теперь последний встреченный X, это тот, который сейчас
        elif i == 'Y':  # Так же как с X
            if y_ind > zero_ind:
                zero_ind = y_ind + 1
            y_ind = ind
        if x_ind > zero_ind and y_ind > zero_ind:  # Если последние встреченные X и Y после элемента,
            # с которого мы считаем, то значит у нас последовательность с 1 X и 1 Y, смотрим ее длину
            m = max((ind - zero_ind + 1), m)  # +1 нужен потому, что длина 2, но символов 3:
            '''
            0 1 | 2 3 4 5 6 7 8 9
            . X | . Y . . . . X .
            например в индексе 8, нам надо взять 2 3 4 5 6 7 8.
            8-2 это 6, но поскольку нас интересует не длина отрезка, а количество точек, это 8-2+1
            '''
    print("13085_tivjnb: ", m)


'''_____________________________________________________________________________________________________________________
№13085 КЕГЭ уровень сложный
В файле содержится строка длиной не более 107 из заглавных букв латинского алфавита (ABC…Z).
Определите в прилагаемом файле максимальную длину подпоследовательности,
 которая состоит из двух последовательных частей (сначала 1 часть, затем 2):
в первой части символы расположены в алфавитном порядке, во второй в обратном алфавитном порядке.
(1-ая и 2-ая часть могут быть различной длины).
Например, для строки QTUHHMSMJFSMECQ ответом будет являться подпоследовательность HHMSMJF (ответ 7),
 в которой 1 часть - HHMS, 2 - часть MJF (разделить можно также на части HHM и SMJF).
'''
n14704 = False
n14704_tivjnb = False
if n14704:
    f = open('task24files/24_14704.txt', 'r').read()
    '''
    Решение с КЕГЭ классное, приведу его:
    Создаем два массива, в первый закидываем сколько слева от него символов в алфавитном порядке
    Во второй сколько справа от него в обратном алфавитному
    затем смотрим для каждого элемента сколько можно взять
    '''
    alp = [0] * len(f)  # Для алфавитного порядка
    ne_alp = [0] * len(f)  # Для не алфавитного порядка
    '''
    Питон может сравнивать символы, и дальше в алфавите символ имеет больший номер, 
    но есть нюанс, русская ё, он ее считает последней
    '''
    alp[0] = 1  # Первый символ априори в алфавитном
    for i in range(1, len(f)):  # Начинаем со второго
        if f[i-1] <= f[i]:  # Если он в алфавитном порядке относительно предыдущего
            alp[i] = alp[i-1] + 1  # То до него в алфавитном порядке столько же,
            # сколько до предыдущего + он сам
        else:  # Если нет
            alp[i] = 1  # То он один в алфавитном

    ne_alp[-1] = 1  # Тут так же, но наоборот
    for i in range(len(f)-2, -1, -1):
        if f[i+1] <= f[i]:
            ne_alp[i] = ne_alp[i+1] + 1
        else:
            ne_alp[i] = 1

    mx = 0  # Для максимального
    for i in range(1, len(f)):  # Каждый берем кроме первого
        mx = max(alp[i-1] + ne_alp[i], mx)  # Смотрим сколько в алфавитном до него этого
        # и сколько в обратном с этого
    print("14704: ", mx)  # УРА ОТВЕТ

if n14704_tivjnb:
    '''
    Ну чисто из принципа выдумал и свое.
    Идея то что мы идем по списку, и когда наш символ не такой как надо, 
    то начинаем считать против алфавита, если до этого считали в алфавитном,
    или обнуляем если уже считали в неалфавитном
    '''
    f = open('task24files/24_14704.txt', 'r').read()
    m = 0  # Для максимального
    pre = ''  # Для предыдущего
    ln = 0  # Для длины
    is_alph = True  # Переключаем то, в каком порядке сейчас
    for i in f:  # проходимся по каждому
        if is_alph:  # Если до этого в алфавитном
            if i < pre:  # И если перестал в нем быть
                is_alph = False  # То переключаем на неалфавитный
        else:  # Если до этого в неалфавитном
            if i > pre:  # И если теперь в алфавитном
                is_alph = True  # То переключаем
                ln = 1  # И обнуляем (1 тк по отношению к предыдущему этот в алфавитном, а значит уже 2 станет)
        pre = i  # Обновляем предыдущий
        ln += 1  # Всегда +1
        m = max(ln, m)  # Сравниваем с максимальным
    print(m)  # УРА ОТВЕТ


'''_____________________________________________________________________________________________________________________
СтатГрад  номер 22(24) https://online.olimpiada.ru/smt-portal/files/a38f709939c18a513add2a11fa69c8594c765ff6.txt
Текстовый файл из заглавных латинских.
Максимальная длина непрерывного фрагмента, начинающегося и оканчивающегося одной и той же буквой
из первой половины алфавита (A-M), и не содержащая данную букву внутри
'''
nStatGrad = False
if nStatGrad:
    f = open('task22files/22_stat_grad.txt', 'r').read()  # Вставьте свое имя, с которым скачали
    '''
    Как я решал:
    Берем для каждой буквы A-M находим список индексов.
    Дальше смотрим на максимальную разницу между соседними индексами.
    '''
    need_alp = 'ABCDEFGHIJKLM'  # Можно жмакнуть на все буквы, отсортировать и отделить лишние

    ind_dict = dict()  # Создаем для каждой буквы элемент в словаре с пустым списком
    for i in need_alp:
        ind_dict[i] = []
    ind_dict = {x: [] for x in need_alp}  # Ну ИЛИ в одну строку

    for ind, i in enumerate(f, 0):  # По каждому символу
        '''
        Опять же, вместо enumerate можно написать
        for ind in range(len(f):
            i = f[ind]
        '''
        if i in ind_dict.keys():  # Если взятый символ из необходимых
            ind_dict[i].append(ind)  # То добавляем его индекс в соответствующий список

    m = 0  # Для максимального
    for i in need_alp:  # По каждой букве
        for x in range(1, len(ind_dict[i])):  # Попарно индексы
            ln = ind_dict[i][x] - ind_dict[i][x-1] + 1  # Смотри расстояние между ними и +1,
            # тк точек больше чем расстояние
            m = max(ln, m)  # Сравниваем с максимальным
    print("СтатГрад", m)  # Ура победа

'''_____________________________________________________________________________________________________________________
Ну и вот 5 заданий с яндекса
'''

n1 = False
if n1:
    f = open('task24files/24yaege1.txt', 'r').read()
    '''
    Текстовый файл состоит не более чем из 10**6 заглавных букв английского алфавита. Найдите максимальную длину подстроки,
    в которой символы I и T не стоят рядом.
    Для выполнения этого задания следует написать программу.
    https://education.yandex.ru/ege/task/301251e4-f9f7-4529-bbe2-446b0af1f949
    Тут тоже проще без замен или чего-то вроде, можно просто пройтись с сохранением предыдущего.
    '''
    ln = 0
    m = 0
    pre = ''
    for i in f:
        if i == 'I' and pre == 'T':
            ln = 0
        elif i == 'T' and pre == 'I':
            ln = 0
        pre = i
        ln += 1
        m = max(m, ln)
    print(m)

n2 = False
if n2:
    f = open('task24files/24yaege2.txt', 'r').read()
    '''
    Текстовый файл состоит из букв D, E, G, O, R, T. Найдите максимальную длину цепочки вида DOGDOGDOGD… 
    Цепочка состоит из повторяющихся фрагментов DOG, последний фрагмент может быть неполным.
    Для выполнения этого задания следует написать программу.
    https://education.yandex.ru/ege/task/73ae4ec6-cd41-42bb-afd7-e6f2b9768217
    Такое, даже сложнее, я решал выше. Заменяем комбинацию на длину, а обрывки на длину и пробелом с той стороны,
    где последовательность обрывается
    '''
    f = f.replace('DOG', '3')
    f = f.replace('DO', '2 ')
    f = f.replace('D', '1 ')

    ln = 0
    m = 0
    for i in f:
        if i in '321':
            ln += int(i)
            m = max(m, ln)
        else:
            ln = 0
    print(m)

n3 = False
if n3:
    '''
    Текстовый файл состоит из символов T, U, V, W, X, Y и Z. 
    Определите в прилагаемом файле максимальное количество идущих подряд символов, 
    среди которых символ T встречается ровно 100 раз, а символ U — ровно 50 раз.
    https://education.yandex.ru/ege/task/b0ac476e-824a-4d0c-8b3f-5c52f208a0ef

    Есть 2 варианта:
    Решаем как обычную со сплитом по одной букве, а потом считать количество U внутри
    то сдвигаем точку отсчета и убираем лишние
    '''

    f = open('task24files/24yaege3.txt', 'r').read()  # Считываем весь файл
    f = f.split('T')  # Сплитим по Т
    m = 0
    for i in range(100, len(f)):  # Будем брать по 101:1 до Т, 99 между Т и 1 после Т
        if sum([f[i - x].count('U') for x in range(0, 101)]) == 50:  # Если сумма количеств U 50, то
            m = max(m, sum([len(f[i - x]) for x in range(101)]) + 100)  # Считаем длину как длина всех отрывков и 100 Т
    print(f"Номер 3: {m}")  # ОТВЕТ

n4 = False
if n4:
    '''
    Текстовый файл состоит не более чем из 10⁶ символов и содержит только десятичные цифры и буквы латинского алфавита.
    Найдите минимальную длину подстроки, содержащей в порядке возрастания все шестнадцатеричные цифры. 
    Строка может включать повторяющиеся цифры и другие символы. В ответе укажите найденную длину.
    Пример: Строка '0XY3Z9ABC1948FRG2333W4' содержит первые 5 символов (из 16 нужных).
    https://education.yandex.ru/ege/task/a63bca73-d464-4237-a1f3-60131bbbee77

    Можно попробовать взять все нули и начинать считать с них
    '''
    f = open('task24files/24yaege4.txt', 'r').read()  # ПЯТЬ(8)
    lf = len(f)  # Я сохранил, так удебннее и, вроде, быстрее
    min_len = lf  # Это для ответа
    z_ind = [x for x in range(lf) if f[x] == '0']  # Находим все нолики
    alp = '0123456789ABCDEF'  # То, что нам надо собрать

    for z in z_ind:  # Пройдемся по каждому нулю
        ns = 1  # Индекс(из строки alp) символа, который мы ищем
        ln = 1  # Скольок символов уже в нашей последовательности. Сейчас тут 1 нолик
        for i in range(z + 1, lf):  # Пройдемся по всем символам от следующего после нуля
            ln += 1  # В любом случае +1 к длине
            if ln > min_len:  # Если у нас получается уже длиннее минимальной,
                break  # то считать незачем, го к следующему нулю.
            if f[i] == alp[ns]:  # Если взятый символ, это необходимый
                ns += 1  # То теперь мы ищем следующий
                if ns == 16:  # Если нашли все 16
                    min_len = ln  # То последовательность готова, сохраняем результат.
                    # min здесь не нужен так как если бы длина была бы больше, то мы бы уже вышли из цикла
                    break  # Ну и все, дальше считать незачем
    print(f"Номер 4: {min_len}")  # Вот и ответ

n5 = False
if n5:
    '''
    https://education.yandex.ru/ege/task/665aedc0-c322-4e16-9c49-6b0449c3e3e6
    Текстовый файл состоит не более, чем из 10⁶ символов из набора A, B, C, D, E, F.
    Найдите максимальную длину строки вида А*А*А*А, где между буквами А расположены одинаковые группы символов,
    не содержащие букв А. Например, в строке BDADBADBADBABDAFABDA такая подстрока ADBADBADBA (длина 10).

    Тут кстати просто вроде, сплит по А и смотрим, одинаковые ли комбинации
    '''
    f = open('task24files/24yaege5.txt', 'r').read()  # С добрым утром
    f = f.split('A')  # Просто сплитим по А. Теперь у нас есть список подстрок между А
    m = 0  # Для макса
    for i in range(1 + 2, len(f) - 1):  # Берем все варианты по 3, кроме первого и последнего потому что они не между А
        comb = [f[i - 2], f[i - 1], f[i]]  # Наши три промежутка
        if len(set(comb)) == 1:  # Если все промежутки одинаковы
            m = max(m, 4 + 3 * len(comb[0]))  # сравниваем длину:
            # 4А и длины промежутков, а так как они одинаковые до 3 длинны одного из них
    print(f"Номер 5: {m}")

n6 = False
if n6:
    '''
    https://education.yandex.ru/ege/task/4e0b8417-3941-4941-8022-bdd0c4586d4e
    Текстовый файл состоит из букв латинского алфавита и десятичных цифр.
    Определите максимальную длину подстроки, которая ограничена с одной стороны буквой A,
     а с другой — D и не содержит других букв A и D внутри.
    '''

    f = open('task24files/24yaege6.txt', 'r').read()

    ln = 0
    m = 0
    pre_AD = ''
    for i in f:
        ln += 1
        if i == 'A':
            if pre_AD == 'D':
                m = max(m, ln)
            ln = 1
            pre_AD = 'A'
        elif i == 'D':

            if pre_AD == 'A':
                m = max(m, ln)
            ln = 1
            pre_AD = 'D'

    print(m)
